<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Evolution &amp; Revolution</title>
    <link>https://lavender1900.github.io/post/</link>
    <description>Recent content in Posts on Evolution &amp; Revolution</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Dec 2019 17:55:25 +0800</lastBuildDate>
    
	<atom:link href="https://lavender1900.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>欧拉筛法</title>
      <link>https://lavender1900.github.io/post/eulers-sieve/</link>
      <pubDate>Thu, 05 Dec 2019 17:55:25 +0800</pubDate>
      
      <guid>https://lavender1900.github.io/post/eulers-sieve/</guid>
      <description>欧拉筛法的核心思想是只对每个数做一次筛去动作，为了做到这个就不能够像埃氏筛法那样对每个数i都划去 i, 2i, 3i, 4i &amp;hellip;
比如整数18 可以因式分解为 2 * 9 或 3 * 6， 这就重复筛了两次，欧拉筛法的做法是只对每个可以因式分解的合数做最小质因子的筛去动作, 因此对于18只会做 2 * 9型的筛去
public int[] solution(int N) { // 标记数组, sieve[i] = true表示i是合数，反之i是素数  boolean[] sieve = new boolean[N]; // prime数组中保存着当前已读取的素数  // 实际上根据素数的密度分布函数，prime的大小远远不需要N  int[] prime = new int[N]; // num表示当前有多少个素数  int num = 0; for (int i = 2; i &amp;lt;= N; i++) { if (!sieve[i]) { prime[num++] = i; } for (int j = 0; j &amp;lt; num; j++) { int m = i * prime[j]; if (m &amp;gt; N) { break; } sieve[m] = true; if (i % prime[j] == 0) { break; } } } return prime; } 算法很有意思，花了挺久时间才理解。做筛除动作的时候，是在当前已经读取的整数空间 S 下进行，例如当前外层循环读到了整数9，那么当前prime数组中保存的素数有prime[] = {2, 3, 5, 7}，当前整数空间 S = 9</description>
    </item>
    
  </channel>
</rss>